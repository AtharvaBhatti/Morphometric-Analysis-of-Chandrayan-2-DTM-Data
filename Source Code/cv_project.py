# -*- coding: utf-8 -*-
"""CV_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w7NgbYxOmwNlOzipjnJ3P9tXi5mCk9Td
"""

! pip install rasterio
!pip install opencv-python

import rasterio
import numpy as np
import matplotlib.pyplot as plt
from skimage.feature import canny
from skimage.transform import hough_circle, hough_circle_peaks
from scipy.ndimage import median_filter
import numpy as np
import matplotlib.pyplot as plt
import cv2
from skimage.measure import label, regionprops

# Load DTM
with rasterio.open('/content/ch2_tmc_ndn_20211221T1917095490_d_dtm_d32.tif') as dtm_src:
    dtm = dtm_src.read(1)
    dtm_meta = dtm_src.meta

# Load Orthoimage
with rasterio.open('/content/ch2_tmc_ndn_20211221T1917095490_d_oth_d32.tif') as ortho_src:
    ortho = ortho_src.read(1)
    ortho_meta = ortho_src.meta

print(type(dtm),"\n",type(ortho), "\n", dtm_meta)
print("DTM Resolution (x, y):", dtm_src.res)
print("Ortho Resolution (x, y):", ortho_src.res)

def crop_image_border(img, crop_pixels=80):
    return img[crop_pixels:-crop_pixels, crop_pixels:-crop_pixels]

dtm = crop_image_border(dtm)
ortho = crop_image_border(ortho)

plt.figure(figsize=(10, 8))
plt.imshow(dtm, cmap='terrain')  # 'terrain' or 'viridis' are great for elevation
plt.title("DTM - Digital Terrain Model")
plt.colorbar(label='Elevation')
plt.axis('off')
plt.show()

plt.figure(figsize=(100, 80))
plt.imshow(ortho, cmap='gray')  # Orthoimages are usually grayscale
plt.title("Orthoimage")
plt.axis('off')
plt.show()

"""Failed edge detetion

"""

# Normalize and convert Ortho image
if ortho.dtype != np.uint8:
    ortho = ((ortho - ortho.min()) / (ortho.max() - ortho.min()) * 255).astype(np.uint8)

if len(ortho.shape) == 2:
    ortho_rgb = cv2.cvtColor(ortho, cv2.COLOR_GRAY2RGB)
else:
    ortho_rgb = ortho.copy()

# --- Step 2: Threshold the DTM to detect depressions ---
threshold = np.percentile(dtm, 20)  # Lowest 5% elevations considered crater regions
crater_mask = dtm < threshold

# Convert to binary mask and clean
crater_mask = crater_mask.astype(np.uint8) * 255
crater_mask = cv2.medianBlur(crater_mask, 5)

# --- Step 3: Label crater regions ---
label_img = label(crater_mask)
regions = regionprops(label_img)

# --- Step 4: Draw bounding boxes on Ortho image ---
for region in regions:
    if region.area > 200:  # Skip small blobs
        minr, minc, maxr, maxc = region.bbox
        cv2.rectangle(ortho_rgb, (minc, minr), (maxc, maxr), (255, 0, 0), 2)  # Red box

# --- Step 5: Show final result ---
plt.figure(figsize=(12, 14))
plt.imshow(ortho_rgb)
plt.title("Crater Detection (Bounding Boxes from DTM Elevation)")
plt.axis("off")
plt.show()

"""1. Visually cropping ortho and DTM sections based on visually identified craters
2. Use given ground truth and location of craters in the meta data to locate the craters.
"""

if len(ortho.shape) == 2:
    # Grayscale image
    plt.hist(ortho.ravel(), bins=256, color='gray')
    plt.title("Ortho Image Histogram (Grayscale - Raw Range)")
else:
    # RGB or Multichannel image
    colors = ('r', 'g', 'b')
    for i, color in enumerate(colors):
        if i < ortho.shape[2]:  # skip non-existent channels
            plt.hist(ortho[:, :, i].ravel(), bins=256, alpha=0.5, color=color, label=f'{color.upper()} Channel')
    plt.legend()
    plt.title("Ortho Image Histogram (Multichannel - Raw Range)")

plt.xlabel("Pixel Value")
plt.ylabel("Frequency")
plt.grid(True)
plt.show()

print(np.max(ortho))
print(np.min(ortho))

from skimage.exposure import rescale_intensity

ortho_8bit = rescale_intensity(ortho, in_range='image', out_range=(0, 255)).astype(np.uint8)

plt.figure(figsize=(8, 8))
plt.imshow(ortho_8bit, cmap='gray')
plt.title("Ortho Image Scaled to 8-bit (0–255)")
plt.axis('off')
plt.show()

plt.hist(ortho_8bit.ravel(), bins=256, color='gray')
plt.title("Ortho Image Histogram (Grayscale - Raw Range)")

# Step 1: Import libraries
import numpy as np
import matplotlib.pyplot as plt
from tifffile import imread
from skimage import measure
from rasterio.transform import from_bounds

# Step 3: Set elevation threshold (tweak -1000 if needed)
threshold = -1125
mask = dtm < threshold

# Step 4: Find contours around low-elevation regions
contours = measure.find_contours(mask.astype(float), level=0.5)

# Step 5: Plot the original DTM with contour boundaries
plt.figure(figsize=(100, 100))
plt.imshow(dtm, cmap='gray')
for contour in contours:
    plt.plot(contour[:, 1], contour[:, 0], linewidth=1.5, color='red')  # x=col, y=row
plt.title("Low Elevation Regions (DTM)")
plt.axis('off')
plt.show()

import numpy as np
import rasterio
from skimage import measure
from skimage.draw import polygon
import os

def save_crater_geotiff_optimized(contour, dtm_array, meta, index):
    """Optimized crater saving using bounding box cropping"""
    # Get bounding box coordinates
    rows, cols = contour[:, 0].astype(int), contour[:, 1].astype(int)
    min_row, max_row = np.min(rows), np.max(rows)
    min_col, max_col = np.min(cols), np.max(cols)

    # Crop the relevant section
    dtm_crop = dtm_array[min_row:max_row+1, min_col:max_col+1]

    # Create localized mask
    mask = np.zeros_like(dtm_crop, dtype=bool)
    rr, cc = polygon(rows - min_row, cols - min_col, dtm_crop.shape)
    mask[rr, cc] = True

    # Calculate new transform
    transform = meta['transform'] * rasterio.Affine.translation(min_col, min_row)

    # Update metadata
    output_meta = meta.copy()
    output_meta.update({
        'height': dtm_crop.shape[0],
        'width': dtm_crop.shape[1],
        'transform': transform,
        'dtype': 'float32',
        'nodata': np.nan
    })

    # Save with compression
    with rasterio.open(f'crater_{index}.tif', 'w', **output_meta, compress='LZW') as dst:
        dst.write(np.where(mask, dtm_crop, np.nan).astype(np.float32), 1)

for idx, contour in enumerate(contours):
    if idx % 2 == 0:
    save_crater_geotiff_optimized(contour, dtm, dtm_meta, idx)

for i in range(1,9):
  with rasterio.open(f"/content/crater_{i}_dtm.tif") as crater_dtm:
    dtm_img = crater_dtm.read(1)
    dtm_shape = dtm_img.shape
    plt.figure(figsize=(10, 8))
    plt.imshow(dtm_img, cmap='terrain')
    plt.title(f"DTM - Crater {i} ({dtm_shape[0]} x {dtm_shape[1]})")

  with rasterio.open(f"/content/crater_{i}_ortho.tif") as crater_ortho:
    ortho_img = crater_ortho.read(1)
    ortho_shape = ortho_img.shape
    plt.figure(figsize=(10, 8))
    plt.imshow(ortho_img, cmap='gray')
    plt.title(f"Ortho - Crater {i} ({ortho_shape[0]} x {ortho_shape[1]})")

import numpy as np
import matplotlib.pyplot as plt
import rasterio
from scipy.ndimage import uniform_filter, maximum_filter, minimum_filter

epsilon = 1e-6  # to avoid division by zero
filter_size = 2  # neighborhood size


for i in range(1, 9):
    # Step 1: Load DTM
    with rasterio.open(f"/content/crater_{i}_dtm.tif") as tri_src:
        dtm_tri = tri_src.read(1).astype(np.float32)

    # Step 2: Mean filter
    mean_dtm = uniform_filter(dtm_tri, size=filter_size)

    # Step 3: Range filter (local max - min)
    max_dtm = maximum_filter(dtm_tri, size=filter_size)
    min_dtm = minimum_filter(dtm_tri, size=filter_size)
    range_dtm = max_dtm - min_dtm

    # Step 4: Normalized image
    TRI = (dtm_tri - mean_dtm) / (range_dtm + epsilon)

    # Step 5: Plot all 3 side by side
    fig, axs = plt.subplots(1, 3, figsize=(18, 6))
    axs[0].imshow(mean_dtm, cmap='terrain')
    axs[0].set_title(f"Mean Filtered - Crater {i}")
    axs[0].axis('off')

    axs[1].imshow(range_dtm, cmap='terrain')
    axs[1].set_title(f"Range Filtered - Crater {i}")
    axs[1].axis('off')

    im = axs[2].imshow(TRI, cmap='YlGnBu', vmin=-3, vmax=3)
    axs[2].set_title(f"TRI =  (DTM - Mean)/Range - Crater {i}")
    axs[2].axis('off')

    # im = axs[2].imshow(TRI, cmap='seismic', vmin=-3, vmax=3)
    # cs = axs[2].contour(TRI, levels=contour_levels, colors='black', linewidths=0.5)
    # axs[2].clabel(cs, inline=True, fontsize=6, fmt="%.1f")
    # axs[2].set_title(f"Normalized + Contour - Crater {i}")
    # axs[2].axis('off')

    #fig.colorbar(im, ax=axs, orientation='vertical', shrink=0.8, label='Contrast Value')
    plt.tight_layout()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import rasterio
from scipy.ndimage import convolve, map_coordinates

# 1) slope‐map as before
def compute_slope(dtm, transform):
    xres, yres = transform.a, -transform.e
    kx = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])/(8*xres)
    ky = np.array([[1,2,1],[0,0,0],[-1,-2,-1]])/(8*yres)
    dzdx = convolve(dtm, kx, mode='nearest')
    dzdy = convolve(dtm, ky, mode='nearest')
    return np.arctan(np.hypot(dzdx, dzdy)) * (180/np.pi)

# 2) rim‐sampling as before
def sample_wall_slope(slope_map, transform, cx, cy, R, arc_step):
    dθ = arc_step / R
    θs = np.arange(0, 2*np.pi, dθ)
    xs = cx + R*np.cos(θs)
    ys = cy + R*np.sin(θs)
    cols = (xs - transform.c) / transform.a
    rows = (ys - transform.f) / transform.e
    vals = map_coordinates(slope_map, [rows, cols], order=1, mode='nearest')
    return xs, ys, vals

# 3) discrete bins & colormap for the rim
bounds = [0, 10, 20, 30, 40, 90]
rim_cmap = mcolors.ListedColormap(['#4fbc02','#b0d232','#ffd42a','#ff6a13','#d73027'])
rim_norm = mcolors.BoundaryNorm(bounds, rim_cmap.N)

for i in range(1,9):
    with rasterio.open(f"/content/crater_{i}_dtm.tif") as src:
        dtm   = src.read(1).astype(np.float32)
        trans = src.transform
        h, w  = dtm.shape

        # auto‐center + radius
        col_c, row_c = w/2, h/2
        cx, cy = trans * (col_c, row_c)
        R = 0.5 * min(w, h) * abs(trans.a)

        # compute slope map
        slope = compute_slope(dtm, trans)

        # sample around the rim
        arc_step = 0.1 * R
        xs, ys, rim_slopes = sample_wall_slope(slope, trans, cx, cy, R, arc_step)

    # --- plot ------------------------------------------------------
    fig, ax = plt.subplots(figsize=(6,6))

    # A) continuous slope‐background
    xmin = trans.c
    xmax = trans.c + w*trans.a
    ymax = trans.f
    ymin = trans.f + h*trans.e
    im = ax.imshow(slope,
                   cmap='terrain',
                   vmin=0, vmax=50,           # clip to 0–50° for better contrast
                   extent=[xmin, xmax, ymin, ymax],
                   origin='upper',
                   interpolation='bilinear')

    # B) discrete rim points
    sc = ax.scatter(xs, ys,
                    c=rim_slopes,
                    cmap=rim_cmap, norm=rim_norm,
                    s=50, edgecolor='k', lw=0.5)

    # C) crisp rim circle
    θfull = np.linspace(0,2*np.pi,360)
    ax.plot(cx + R*np.cos(θfull), cy + R*np.sin(θfull),
            color='black', lw=1)

    ax.set_aspect('equal')
    ax.set_axis_off()
    ax.set_title(f"Crater {i}  Slope map + wall slope")

    # D) colourbars
    cax1 = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    cax1.set_label("Slope (°) — background")
    cax2 = fig.colorbar(sc, ax=ax, boundaries=bounds,
                        ticks=bounds, fraction=0.046, pad=0.02)
    cax2.set_label("Wall‐slope (°) — discrete bins")

    plt.tight_layout()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt
import rasterio
from sklearn.linear_model import LinearRegression

def compute_max_wall_slope(dtm, transform, cx, cy, R):
    """Calculate max slope along crater walls using elevation profile regression"""
    num_angles = 360  # δθ = 1°
    max_slopes = []

    for θ in np.linspace(0, 2*np.pi, num_angles):
        # Create radial profile from 0.2R to 0.7R
        profile_R = np.linspace(0.2*R, 0.7*R, 1000)
        x_profile = cx + profile_R * np.cos(θ)
        y_profile = cy + profile_R * np.sin(θ)

        # Sample DTM along profile
        rows, cols = rasterio.transform.rowcol(transform,
                                             x_profile,
                                             y_profile)
        elevations = dtm[rows, cols]

        # Split into 0.1R segments
        segment_length = int(0.1 * R / (profile_R[1]-profile_R[0]))
        slopes = []

        for i in range(0, len(elevations), segment_length):
            segment = elevations[i:i+segment_length]
            if len(segment) < 2: continue

            # Linear regression for slope
            X = profile_R[i:i+segment_length].reshape(-1,1)
            y = segment
            model = LinearRegression().fit(X, y)
            slope_deg = np.degrees(np.arctan(model.coef_[0]))
            slopes.append(slope_deg)

        if slopes:
            max_slopes.append(np.nanmax(slopes))

    return np.nanmean(max_slopes) if max_slopes else 0

# Modified visualization code
for i in range(1,9):
    with rasterio.open(f"/content/crater_{i}_dtm.tif") as src:
        dtm = src.read(1)
        transform = src.transform

        # Calculate crater parameters
        col_c, row_c = dtm.shape[1]//2, dtm.shape[0]//2
        cx, cy = src.xy(row_c, col_c)
        R = 0.5 * min(dtm.shape) * src.res[0]

        # Compute max wall slope
        max_slope = compute_max_wall_slope(dtm, transform, cx, cy, R)

        # Create plot
        fig, ax = plt.subplots(figsize=(8,8))

        # Plot elevation map
        ax.imshow(dtm, extent=[cx-R, cx+R, cy-R, cy+R],
                 cmap='terrain', origin='upper')

        # Annotate with calculated slope
        ax.text(0.05, 0.95, f"Max wall slope: {max_slope:.1f}°",
               transform=ax.transAxes, backgroundcolor='white')

        ax.set_title(f"Crater {i} - Wall Slope Analysis")
        ax.set_axis_off()
        plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Load crater data
df = pd.read_csv(r"D:\CV\run\crater_outputs\profiles\crater_metrics.csv")

# Extract diameter and depth
D = df["diameter_m"].values.reshape(-1, 1)
d = df["depth_m"].values.reshape(-1, 1)

# (a) Regression for all craters
model_all = LinearRegression().fit(D, d)
d_pred_all = model_all.predict(D)
r2_all = model_all.score(D, d)
m_all = model_all.coef_[0][0]
c_all = model_all.intercept_[0]

# ─── Plotting ─────────────────────────────────────────────
fig, ax = plt.subplots(figsize=(8, 6))

# (a) Depth–Diameter regression
ax.scatter(D, d, color='black')
ax.plot(D, d_pred_all, color='red')
ax.set_title("Depth–Diameter Relationship")
ax.set_xlabel("Diameter (m)")
ax.set_ylabel("Depth (m)")
ax.grid(True)
ax.text(0.05, 0.95,
        f"d = {m_all:.4f}*D + {c_all:.1f}\nR² = {r2_all:.2f}",
        transform=ax.transAxes,
        verticalalignment='top',
        bbox=dict(facecolor="white", edgecolor="gray"))

plt.tight_layout()
plt.show()

import rasterio
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter1d

# 1) Load the DTM
dtm_path = r'D:\CV\run\crater_outputs\crater_6_dtm.tif'
with rasterio.open(dtm_path) as src:
    dtm = src.read(1)
    transform = src.transform

# 2) Lunar‐meters per degree at your crater latitude
R = 1_737_400  # lunar radius in meters
phi_center = 9.254512  # your crater center latitude in degrees
m_per_deg_lat = 2 * np.pi * R / 360
m_per_deg_lon = m_per_deg_lat * np.cos(np.deg2rad(phi_center))

# 3) Pixel size in meters
dx_m = transform.a * m_per_deg_lon
dy_m = -transform.e * m_per_deg_lat

# 4) Extract a horizontal profile through the center row
row = dtm.shape[0] // 2
profile = dtm[row, :]

# 5) Build a distance axis in meters
distance = np.arange(profile.size) * dx_m

# 6) Smooth profile and find rim & bottom indices
smoothed = gaussian_filter1d(profile, sigma=3)
min_idx   = np.argmin(smoothed)
left_rc   = np.argmax(smoothed[:min_idx])
right_rc  = np.argmax(smoothed[min_idx:]) + min_idx

# 7) Compute diameter (D), depth (d), and ratio d/D
D = distance[right_rc] - distance[left_rc]                     # rim-to-rim in meters
d = smoothed[[left_rc, right_rc]].mean() - smoothed[min_idx]    # mean rim elevation minus bottom

d_over_D = d / D

# 8) Print the results
print(f"Diameter (D) = {D:.1f} m")
print(f"Depth    (d) = {d:.1f} m")
print(f"d/D         = {d_over_D:.3f}")

# 9) (Optional) Plot the profile
plt.figure(figsize=(10,5))
plt.plot(distance, smoothed, label='Smoothed Elevation')
plt.scatter(distance[[left_rc, right_rc]], smoothed[[left_rc, right_rc]], c='red', label='Rims (Rc)')
plt.scatter(distance[min_idx], smoothed[min_idx], c='blue', label='Crater Bottom')
plt.title(f'Crater Profile: D≈{D:.1f} m, d≈{d:.1f} m, d/D≈{d_over_D:.3f}')
plt.xlabel('Distance (m)')
plt.ylabel('Elevation (m)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()